// 在显示着数字的坏计算器上，我们可以执行以下两种操作：

// 双倍（Double）：将显示屏上的数字乘 2；
// 递减（Decrement）：将显示屏上的数字减 1 。
// 最初，计算器显示数字 X。

// 返回显示数字 Y 所需的最小操作数。

//  

// 示例 1：

// 输入：X = 2, Y = 3
// 输出：2
// 解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
// 示例 2：

// 输入：X = 5, Y = 8
// 输出：2
// 解释：先递减，再双倍 {5 -> 4 -> 8}.
// 示例 3：

// 输入：X = 3, Y = 10
// 输出：3
// 解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.
// 示例 4：

// 输入：X = 1024, Y = 1
// 输出：1023
// 解释：执行递减运算 1023 次
/**
 * @param {number} X
 * @param {number} Y
 * @return {number}
 */

// 思路:
// X < Y,对于X而言,到达Y有两种方式：
// 1. X优先执行"倍增"(假设操作数=countFitst),等到大于并最靠近Y的时候，执行"递减"(假设操作数=countSecond)。
// 2. X优先执行"倍增"+"递减"找到Y的1/2值或1/4值或1/8值或...(假设操作数=countFitst),然后执行"倍增",直到x==Y(假设操作数=countSecond)。

// 那么上面那种方法好呢？显然是方法2！！！
// 因为假如Y比X大很多很多，那么会导致X最后一次的倍增产生的增量变得很大，那么递减次数会也会很大，也就是方法1中的countSecond变得很大；
// 方法2则在一开始增量小的时候，就找到倍增开始的点，也就使得方法2中的countFitst比方法1中的countSecond小的多。

// 但是方法2也存在一个比较严重的问题？如何找到倍增开始的点，也就是如何确定Y的1/2值或1/4值或1/8值或...，这个逻辑是复杂的。

// 因此我们采用逆向思维，操作Y，那么X的递减等价Y的递增，X的倍增等价Y的倍减。在Y>X时Y只管/2，到了Y<X时在+1逼近 说白了就是，
// 正向思维采用的是先小跨度的-1操作，再大跨度的*2操作；逆向思维采用的是先大跨度的/2操作，再小跨度的+1操作 然而事实上往往
// 是先大后小的解决问题思维在实现起来会比较简单

// Y 只能倍减或递增
var brokenCalc = function (X, Y) {
    // 1. 循环
    let ans = 0;
    while (Y > X) {
        ans++;
        if (Y % 2 == 1)
            Y++;
        else
            Y /= 2;
    }

    return ans + X - Y;
    // 2. 递归写法
    // if (X >= Y) {
    //     return X - Y;
    // }
    // if (Y % 2 == 0)
    //     // 是偶数，那么直接不断地倍减
    //     return 1 + brokenCalc(X, Y / 2);
    // else
    //     // Y是奇数的时候，只能递增变为偶数来倍减
    //     return 1 + brokenCalc(X, Y + 1);

};